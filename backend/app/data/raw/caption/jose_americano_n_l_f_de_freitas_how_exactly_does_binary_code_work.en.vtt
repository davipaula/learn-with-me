WEBVTT
Kind: captions
Language: en

00:00:06.777 --> 00:00:11.415
Imagine trying to use words 
to describe every scene in a film,

00:00:11.415 --> 00:00:13.318
every note in your favorite song,

00:00:13.318 --> 00:00:16.035
or every street in your town.

00:00:16.035 --> 00:00:20.859
Now imagine trying to do it using 
only the numbers 1 and 0.

00:00:20.859 --> 00:00:23.754
Every time you use the Internet
to watch a movie,

00:00:23.754 --> 00:00:24.863
listen to music,

00:00:24.863 --> 00:00:26.349
or check directions,

00:00:26.349 --> 00:00:28.859
that’s exactly what your device is doing,

00:00:28.859 --> 00:00:31.812
using the language of binary code.

00:00:31.812 --> 00:00:36.502
Computers use binary because 
it's a reliable way of storing data.

00:00:36.502 --> 00:00:40.577
For example, a computer's main
memory is made of transistors

00:00:40.577 --> 00:00:44.154
that switch between either high 
or low voltage levels,

00:00:44.154 --> 00:00:47.644
such as 5 volts and 0 volts.

00:00:47.644 --> 00:00:51.750
Voltages sometimes oscillate,
but since there are only two options,

00:00:51.750 --> 00:00:55.751
a value of 1 volt 
would still be read as "low."

00:00:55.751 --> 00:00:58.280
That reading is done by 
the computer’s processor,

00:00:58.280 --> 00:01:02.595
which uses the transistors’ states 
to control other computer devices

00:01:02.595 --> 00:01:04.791
according to software instructions.

00:01:04.791 --> 00:01:08.132
The genius of this system 
is that a given binary sequence

00:01:08.132 --> 00:01:11.520
doesn't have a pre-determined meaning 
on its own.

00:01:11.520 --> 00:01:15.205
Instead, each type of data
is encoded in binary

00:01:15.205 --> 00:01:18.115
according to a separate 
set of rules.

00:01:18.115 --> 00:01:19.497
Let’s take numbers.

00:01:19.497 --> 00:01:21.179
In normal decimal notation, 

00:01:21.179 --> 00:01:26.032
each digit is multiplied by 10 raised 
to the value of its position,

00:01:26.032 --> 00:01:28.483
starting from zero on the right.

00:01:28.483 --> 00:01:35.040
So 84 in decimal form is 4x10⁰ + 8x10¹.

00:01:35.040 --> 00:01:37.755
Binary number notation works similarly,

00:01:37.755 --> 00:01:41.561
but with each position 
based on 2 raised to some power.

00:01:41.561 --> 00:01:45.573
So 84 would be written as follows:

00:01:45.573 --> 00:01:50.376
Meanwhile, letters are interpreted 
based on standard rules like UTF-8,

00:01:50.376 --> 00:01:55.483
which assigns each character to a specific
group of 8-digit binary strings.

00:01:55.483 --> 00:02:02.389
In this case, 01010100 corresponds 
to the letter T.

00:02:02.389 --> 00:02:06.147
So, how can you know whether 
a given instance of this sequence

00:02:06.147 --> 00:02:08.832
is supposed to mean T or 84?

00:02:08.832 --> 00:02:11.870
Well, you can’t from seeing 
the string alone

00:02:11.870 --> 00:02:16.442
– just as you can’t tell what the sound
"da" means from hearing it in isolation.

00:02:16.442 --> 00:02:21.279
You need context to tell whether you're
hearing Russian, Spanish, or English.

00:02:21.279 --> 00:02:22.670
And you need similar context

00:02:22.670 --> 00:02:26.785
to tell whether you’re looking 
at binary numbers or binary text.

00:02:26.785 --> 00:02:31.146
Binary code is also used for 
far more complex types of data.

00:02:31.146 --> 00:02:33.492
Each frame of this video, for instance,

00:02:33.492 --> 00:02:35.960
is made of hundreds 
of thousands of pixels.

00:02:35.960 --> 00:02:37.641
In color images,

00:02:37.641 --> 00:02:41.095
every pixel is represented 
by three binary sequences

00:02:41.095 --> 00:02:43.701
that correspond to the primary colors.

00:02:43.701 --> 00:02:45.487
Each sequence encodes a number

00:02:45.487 --> 00:02:48.671
that determines
the intensity of that particular color.

00:02:48.671 --> 00:02:52.600
Then, a video driver program transmits 
this information

00:02:52.600 --> 00:02:55.310
to the millions of liquid crystals 
in your screen

00:02:55.310 --> 00:02:58.088
to make all the different hues 
you see now.

00:02:58.088 --> 00:03:01.402
The sound in this video 
is also stored in binary,

00:03:01.402 --> 00:03:04.806
with the help of a technique 
called pulse code modulation.

00:03:04.806 --> 00:03:07.190
Continuous sound waves are digitized

00:03:07.190 --> 00:03:11.582
by taking "snapshots" of their 
amplitudes every few milliseconds.

00:03:11.582 --> 00:03:15.247
These are recorded as numbers 
in the form of binary strings,

00:03:15.247 --> 00:03:19.160
with as many as 44,000
for every second of sound.

00:03:19.160 --> 00:03:21.770
When they’re read by 
your computer’s audio software,

00:03:21.770 --> 00:03:26.124
the numbers determine how quickly 
the coils in your speakers should vibrate

00:03:26.124 --> 00:03:28.965
to create sounds of different frequencies.

00:03:28.965 --> 00:03:32.660
All of this requires billions 
and billions of bits.

00:03:32.660 --> 00:03:36.663
But that amount can be reduced 
through clever compression formats.

00:03:36.663 --> 00:03:41.171
For example, if a picture has 30 adjacent 
pixels of green space,

00:03:41.171 --> 00:03:46.019
they can be recorded as "30 green" instead
of coding each pixel separately -

00:03:46.019 --> 00:03:49.194
a process known as run-length encoding.

00:03:49.194 --> 00:03:54.094
These compressed formats are themselves 
written in binary code.

00:03:54.094 --> 00:03:57.164
So is binary the end-all-be-all 
of computing?

00:03:57.164 --> 00:03:58.549
Not necessarily.

00:03:58.549 --> 00:04:00.967
There’s been research 
into ternary computers,

00:04:00.967 --> 00:04:03.432
with circuits in three possible states,

00:04:03.432 --> 00:04:05.252
and even quantum computers,

00:04:05.252 --> 00:04:08.916
whose circuits can be
in multiple states simultaneously.

00:04:08.916 --> 00:04:11.339
But so far, none of these has provided

00:04:11.339 --> 00:04:14.635
as much physical stability 
for data storage and transmission.

00:04:14.635 --> 00:04:17.079
So for now, everything you see,

00:04:17.079 --> 00:04:17.848
hear,

00:04:17.848 --> 00:04:19.464
and read through your screen

00:04:19.464 --> 00:04:23.097
comes to you as the result 
of a simple "true" or "false" choice,

00:04:23.097 --> 00:04:25.371
made billions of times over.

